---
title: "Project 2 Description"
date: "`r Sys.Date()`"
output: html_document
---
<!--
To update Github with your own code: 
1. PULL
From the Git tab, “Pull” the repository. This makes sure your local repository is synced with the remote repository. This is very important if other people are making changes to the repository or if you are working from multiple computers. 
2. STAGE
Select (aka. stage) the files you want to commit. In RStudio, this involves checking the “Staged” boxes in the Git tab. 
3. COMMIT
Try to add a note so everyone will know what you're changing. 
4. PUSH
Saves these local changes to the online repository.
-->
## Overview

This document contains instructions on Project 2 for STA 141A in Winter 2021. This document is made with `R markdown`. The `rmd` file to generate this document is available on the course website.

# Background



## WHO COVID-19 data

We will do an EDA for the WHO COVID-19 data. You can take a look at the [weekly WHO COVID-19 update](https://www.who.int/emergencies/diseases/novel-coronavirus-2019/situation-reports) for reference.


```{r echo=TRUE, eval=TRUE}
# library(tidyverse)
# covid <- read_csv("https://covid19.who.int/WHO-COVID-19-global-data.csv")
```

This data set is maintained by WHO and updated constantly. The first task for you is to understand this data set, e.g., the meaning of the variables and their values. To this end, you can make use of your preferred search engine, or read the documentation for this data set. 

In this project, you are a team of conscientious statisticians, who wish to help the general public understand the ongoing pandemic. 



## Suggested outline 

The following list provides one potential structure of the data analysis report. As this is the final project, the following suggestions are intended to provide one viable route for your project while leaving you as much freedom as possible. 

***

0. Before writing your analysis report, you may want to explore this data set and read about the coronavirus to generate the hypothesis or question to be answered in this report, i.e., the question(s) of interest. You can be creative on this question so long as it meets three conditions.

    a. This question might be meaningful in real-world. 
    b. A method discussed in this course is employed in solving this question. 
    c. This question does not ask for causality.  



***


1. Introduce the dataset and the questions of interest. 

2. Review the background of the coronavirus. 

3. Explore this dataset and generate summary statistics that you find informative, and explain your findings. <span style="color:red"> The summary statistics should include at least time, number of cases, number of death, case-mortality rate.</span>
<!-- RAHUL AND I START WITH THIS ONE -->
```{r, echo=FALSE}
# install.packages("usethis")
library(usethis)
    use_git_config(user.name = "Richard-Ge", user.email = "richardge951@gmail.com")
library(tidyverse)
    covid <- read_csv("https://covid19.who.int/WHO-COVID-19-global-data.csv")
library(lubridate)
# install.packages("rvest")
library(rvest)
library(data.table)
```

```{r, echo=FALSE}
head(covid) # View(covid)
covid = mutate(covid, WHO_region = fct_recode(WHO_region,"Eastern Mediterranean"="EMRO","Europe" = "EURO","Africa" = "AFRO","Western Pacific" = "WPRO","Americas"="AMRO","South-East Asia" = "SEARO"))

pop.data = read.csv("~/Documents/STA141A-pop-data.csv", row.names=1)  # View(pop.data)
obesity = read_tsv("~/Documents/obesity.tsv")
    obesity = obesity %>% transmute(Country=obesity$Country,ObesityPrc=obesity$Obesity_rate) %>% data.frame()
elderly = read_tsv("~/Documents/elderly2017WB.tsv")
    elderly = elderly %>% transmute(Country=elderly$Country,ElderlyPrc=elderly$`c-65+`) %>% data.frame()
healthcare = read_tsv("~/Documents/healthcare.tsv")
    healthcare = healthcare %>% transmute(Country=healthcare$Country,HCSpentPerCap=healthcare$pc2018) %>% data.frame()
aqis = read_tsv("~/Documents/country-aqi.tsv")
    # no need to transmute
pop_dens = read_tsv("~/Documents/pop_dens.tsv")
    pop_dens = pop_dens %>% transmute(Country=pop_dens$Country,km.density=pop_dens$km_PopDens) %>% data.frame()
incomes = read_tsv("~/Documents/incomes.tsv")
    incomes = incomes %>% transmute(Country=incomes$Country,med.wealth=incomes$MedWealth) %>% data.frame()
HDIs = read_tsv("~/Documents/countryHDIs.tsv")
    HDIs = HDIs %>% transmute(Country=HDIs$Country,HDIadj=HDIs$HDI.ineq) %>% data.frame()

# renaming
pop.data[85, 1] = "Dominican Republic"
pop.data[188, 1] = "American Samoa"
pop.data[16, 1] = "Democratic Republic of the Congo"
pop.data[19, 1] = "Iran (Islamic Republic of)"
pop.data[21, 1] = "The United Kingdom"
pop.data[50, 1] = "Venezuela (Bolivarian Republic of)"
pop.data[81, 1] = "Bolivia (Plurinational State of)"
pop.data[86, 1] = "Czechia"
pop.data = rbind(pop.data, Country = c("Andorra", as.numeric(77543)))
pop.data = rbind(pop.data, Country = c("Latvia", as.numeric(1907675)))
# pop.data = rbind(pop.data, Country = c("Liechtenstein", as.numeric(38250)))
pop.data = rbind(pop.data, Country = c("Moldova", as.numeric(2640438)))
# pop.data = rbind(pop.data, Country = c("Monaco", as.numeric(38300)))
pop.data = rbind(pop.data, Country = c("Moldova", as.numeric(2640438)))
pop.data = rbind(pop.data, Country = c("Russia", as.numeric(146238185)))
pop.data = mutate(pop.data, Population = as.numeric(Population))  # ^^^ gets inputted as char for some reason
obesity[46, 1] = "Czechia"
obesity[36, 1] = "The United Kingdom"
obesity = mutate(obesity, ObesityPrc = as.numeric(ObesityPrc))
elderly = rbind(elderly, Country = c("Andorra", as.numeric(17.4)))
elderly[46, 1] = "Czechia"
elderly[182, 1] = "The United Kingdom"
elderly = mutate(elderly, ElderlyPrc = as.numeric(ElderlyPrc))
# for the healthcare data, i realized that i could just edit the tsv itself...no need for all those reassignments...

newcovid = left_join(covid, pop.data, by = c("Country"))
newcovid = left_join(newcovid, obesity, by = c("Country"))
newcovid = left_join(newcovid, elderly, by = c("Country"))
newcovid = left_join(newcovid, healthcare, by = c("Country"))
newcovid = left_join(newcovid, aqis, by = c("Country"))
newcovid = left_join(newcovid, pop_dens, by = c("Country"))
newcovid = left_join(newcovid, incomes, by = c("Country"))
newcovid = left_join(newcovid, HDIs, by = c("Country"))

    # put new populations here, by name
# View(newcovid); View(pop.data)   # got confused: saw the same pop. many times
newcovid = filter(newcovid, !is.na(newcovid$Population))  # REMOVE NA pop. countries
worldpop = sum(unique(newcovid$Population), na.rm = T)     # having NA values makes output NA too
newcovid = mutate(newcovid, 
                  prcCNew=New_cases*100/Population,       # new cases/pop -> %
                  prcCTotal=Cumulative_cases*100/Population, # total cases/pop -> %
                  prcDNew=New_deaths*100/Population,   # new deaths/pop -> %
                  prcDTotal=Cumulative_deaths*100/Population, # total deaths/pop -> %
                  mortality.now=Cumulative_deaths/Cumulative_cases)  
# View(newcovid)
## TODO: get summary statistics e.g. total deaths (+ per region), percent of country infected, etc. Make a table called "summary statistics" and name the columns!

covid20 = newcovid %>% filter(Date_reported < "2021-01-01")  # View(covid20)
covid21 = newcovid %>% filter(Date_reported >= "2021-01-01")


time.since.start = max(covid$Date_reported) - min(covid$Date_reported)
time.since.first = max(covid$Date_reported) - ymd("2020-1-24")
recent.data = filter(covid21, Date_reported == Sys.Date()-1)  # or today()
# creating dataset for "europe pre-existing markers" model:
EUcountries = c("Austria", "Belgium", "Bulgaria", "Croatia", "Cyprus", "Czechia", "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", "Hungary", "Ireland", "Italy", "Latvia", "Lithuania", "Luxembourg", "Malta", "Netherlands", "Poland", "Portugal", "Romania", "Slovakia", "Slovenia", "Spain", "Sweden")
nonEUcountries = c("Albania", "Andorra", "Armenia", "Azerbaijan", "Belarus", "Bosnia and Herzegovina", "Georgia", "Iceland", "Liechtenstein", "Moldova", "Monaco", "Montenegro", "Norway", "Russia", "Serbia", "Switzerland", "Turkey", "Ukraine", "The United Kingdom")
europecovid = filter(newcovid, newcovid$Country %in% c(EUcountries, nonEUcountries))
 # sort(c(EUcountries, nonEUcountries)); sort(unique(europecovid$Country))
europe.recent = filter(europecovid, Date_reported == Sys.Date()-1)  # View(recent.europe)
    # latvia is reported twice?
# mutate(europecovid, Population = )


# Summary Statistics: include at least time, number of cases, number of death, case-mortality rate.
eu.total.cases = sum(europe.recent$Cumulative_cases)
eu.total.deaths = sum(europe.recent$Cumulative_deaths)
eu.total.mortality = eu.total.deaths*100/eu.total.cases
eu.mean.cases = sum(europecovid$prcCNew)/as.numeric(time.since.first)
eu.median.cases = median(europecovid$prcCNew)
eu.stats = data.frame(time.since.start, time.since.first, eu.total.cases, eu.total.deaths, eu.total.mortality, eu.mean.cases, eu.median.cases)
names(eu.stats) = c("Days since WHO data began", "Days since first reported case", "Total Cases", "Total Deaths", "Total Mortality (as %)", "Mean of % Changes in Case Numbers", "Median of % Changes in Case Numbers")
# View(europe.recent); View(pop.data); View(covid21)
### time since first case, cases, prc. of total cases, deaths, prc. of total deaths, mortality rate
# time.since.first.case = c(0, 0, 0)
cases = c(0, 0)
# prc.total.cases = c(0, 0, 0)
deaths = c(0, 0)
# prc.total.deaths = c(0, 0, 0)
# mortality.rate = c(0, 0, 0)
summarystats = data.frame(cases, deaths, row.names=c("Selected EU countries", "Selected Non-EU Countries"))
europop = sum(europe.recent$Population)
for(country1 in unique(europecovid$Country)){
  # print(country)
  if((country1 %in% EUcountries)) {
    thiscountry = filter(europe.recent, Country==country1)
    summarystats[1,1] = summarystats[1,1] + unique(thiscountry$Cumulative_cases)
    #summarystats[1,2] = summarystats[1,2] + unique(thiscountry$Cumulative_cases)*100/europop
    summarystats[1,2] = summarystats[1,2] + unique(thiscountry$Cumulative_deaths)
    #summarystats[1,4] = summarystats[1,4] + unique(thiscountry$Cumulative_deaths)*100/europop
    # summarystats[1,5] = summarystats[1,5] + unique(thiscountry$mortality.now)
    # print(cat("EU:  ", country1, unique(thiscountry$Cumulative_cases)))
  } 
  if((country1 %in% nonEUcountries)){
    thiscountry = filter(europe.recent, Country==country1)
    summarystats[2,1] = summarystats[2,1] + unique(thiscountry$Cumulative_cases)
    #summarystats[2,2] = summarystats[2,2] + unique(thiscountry$Cumulative_cases)*100/europop
    summarystats[2,2] = summarystats[2,2] + unique(thiscountry$Cumulative_deaths)
    #summarystats[2,4] = summarystats[2,4] + unique(thiscountry$Cumulative_deaths)*100/europop
    # summarystats[2,5] = summarystats[2,5] + unique(thiscountry$mortality.now)
    # print(cat("Not: ", country1, unique(thiscountry$Cumulative_cases)))
  }
}
#summarystats[3,1] = summarystats[1,1] + summarystats[2,1]
#summarystats[3,2] = (summarystats[1,1] + summarystats[2,1])*100/sum(europe.recent$Population)
#summarystats[3,2] = summarystats[1,2] + summarystats[2,2]
#summarystats[3,4] = summarystats[1,4] + summarystats[2,4]
#summarystats[3,5] = summarystats[1,5] + summarystats[2,5]
names(summarystats) = c("Total Cases", "Total Deaths")
eu.stats; summarystats
```

4.  Propose an appropriate model to answer the questions of interest. 
      a. Explain your notations. 
      b. State assumptions for your model. 
      c. Explain why your model is appropriate for this task. 

One model we will use is the simple linear model, which is defined as follows: $$Y_{i} = \beta_{0} + \beta_{1}X_{i1} + \beta_{2}X_{i2} + ... + \beta_{p}X_{ip} + \epsilon_{i}$$ 

There are $p+1$ (when including the intercept $\beta_{0}$) coefficients $\beta_{p}$, $p$ predictor variables $X_{ip}$, and outcome variables $Y_i$. The error terms are represented by $\epsilon_{i}$. The index $i$ denotes the $i$'th observation (in our context, the $i$'th country analyzed), while the index $p$ denotes the $p$'th predictor ($p$ denotes a metric for measuing countries, while the intercept of the model is at $p=0$).

The assumptions are as follows: there is a linear relationship between the predictor and outcome variables, the variables are independent from each other, no multicollinearity, and the residuals are linear and normally distributed. 

This model is ideal for analyzing what pre-COVID metrics of a country are associated with the current mortality rate, because all of the variables are continuous. Furthermore, there is only one outcome variable, and many possible predictor variables, which are well-suited to linear dimension reduction methods. 

The second model we will use is the analysis of variance model, which is defined as follows: $$$$

```{r, echo=FALSE}

groups = as.data.table(europecovid)
    # get highest days of new/total cases and new/total deaths
europe.highest.CNew = groups[groups[, .I[prcCNew==max(prcCNew)], by=Country]$V1]
#dim(europe.highest.CNew);length(unique(europe.highest.CNew$prcCNew)) # no repeats
europe.highest.CNew = europe.highest.CNew %>% mutate(  #orig. HC, med.wealth only
  HCSpentPerCap = scale(HCSpentPerCap), 
  med.wealth=scale(med.wealth), 
  ElderlyPrc=scale(ElderlyPrc),
  ObesityPrc=scale(ObesityPrc),
  AQI=scale(AQI),
  km.density=scale(km.density),
  prcCNew=scale(prcCNew),
  )

europe.highest.CTotal = groups[groups[, .I[prcCTotal==max(prcCTotal)], by=Country]$V1]
#dim(europe.highest.CTotal);length(unique(europe.highest.CTotal$prcCTotal)) # a few repeats!
europe.highest.CTotal=europe.highest.CTotal[!duplicated(europe.highest.CTotal$prcCTotal), ]  # from stackoverflow
europe.highest.CTotal = europe.highest.CTotal %>% mutate(  #orig. HC, med.wealth only
  HCSpentPerCap = scale(HCSpentPerCap), 
  med.wealth=scale(med.wealth), 
  ElderlyPrc=scale(ElderlyPrc),
  ObesityPrc=scale(ObesityPrc),
  AQI=scale(AQI),
  km.density=scale(km.density),
  prcCTotal=scale(prcCTotal),
)

europe.highest.DNew = groups[groups[, .I[prcDNew==max(prcDNew)], by=Country]$V1]
#dim(europe.highest.DNew);length(unique(europe.highest.DNew$prcDNew)) # a few repeats!
europe.highest.DNew=europe.highest.DNew[!duplicated(europe.highest.DNew$prcDNew), ]
europe.highest.DNew = europe.highest.DNew %>% mutate( 
  HCSpentPerCap = scale(HCSpentPerCap), 
  med.wealth=scale(med.wealth), 
  ElderlyPrc=scale(ElderlyPrc),
  ObesityPrc=scale(ObesityPrc),
  AQI=scale(AQI),
  km.density=scale(km.density),
  prcDNew=scale(prcDNew),
  )

europe.highest.DTotal = groups[groups[, .I[prcDTotal==unique(max(prcDTotal))], by=Country]$V1]
#dim(europe.highest.DTotal);length(unique(europe.highest.DTotal$prcDTotal)) # many repeats!
europe.highest.DTotal=europe.highest.DTotal[!duplicated(europe.highest.DTotal$prcDTotal), ]
europe.highest.DTotal = europe.highest.DTotal %>% mutate(  #orig. HC, med.wealth only
  HCSpentPerCap = scale(HCSpentPerCap), 
  med.wealth=scale(med.wealth), 
  ElderlyPrc=scale(ElderlyPrc),
  ObesityPrc=scale(ObesityPrc),
  AQI=scale(AQI),
  km.density=scale(km.density),
  prcDTotal=scale(prcDTotal),
  )

# plot(europe.highest.DTotal$km.density)  ## big outlier: malta


# View(filter(europecovid, Country=="Finland"))     View(europe.highest)

# OLD PLANS: 
## simple linreg (+ x-var squared?) for the whole time, or for each year/month/week
  # can we do many models instead of just 1?
### we might be able to GROUP these months/weeks to satisfy condition B
### or PCA the countries for dimension reduction! <ASK PROF: what do the PC's even mean?> youtube.com/watch?v=VjsO5bLe4yg
  # does PCA count as a model? or do we just use it to select the most important variables?
  # analyze countries/regions separately from each other?
### data is specifically the # or % of new cases
  # analyze countries with negative values separately? what do we do?
## time series model? towardsdatascience.com/the-complete-guide-to-time-series-analysis-and-forecasting-70d476bfe775
    ## CHANGE THE QUESTION that we want to answer, in order to avoid needing time series analysis! <?>

# We have (2) dimensions of (419+each_day/188+extra_countries) predictors we can analyze: date, country
# We have (1) dimension of (4) outcomes we can analyze: % new/total cases/deaths
# I'm thinking, if we do PCA, we can have "countries" as PCs and "% new cases" as the data, kind of like how we did PCA for babynames. Either way, can we only decrease one dimension of variables (e.g. which countries/dates contribute most)? Or can we PCA two dimensions of variables at once (e.g. which countries AND dates contribute most)? 
  ## maybe find which days/countries were most severe, and then do further analysis? could this just end up finding the max of each? FIND LOCKDOWN INFO!
```

5.  Fit the proposed model in (4) and explain your results. 

```{r, echo=FALSE}
#dont use CNew, DNew yet because the day-to-day variation is too high, and the ways it can change are too numerous. we want to look at how things that happened before the pandemic even started are affecting the outcome
#### We will use mortality rate as the outcome variable because it doesn't just go up all the time, instead staying at a specific rate that can only go up or down very slightly. TODO: add "change in mortality" as a variable?

#preCOVIDtoCNew = lm(prcCNew~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth+HDIadj, data=europe.highest.CNew); summary(preCOVIDtoCNew); anova(preCOVIDtoCNew)
#preCOVIDtoCTotal = lm(prcCTotal~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth+HDIadj, data=europe.highest.CTotal); summary(preCOVIDtoCTotal); anova(preCOVIDtoCTotal)
#preCOVIDtoDNew = lm(prcDNew~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth+HDIadj, data=europe.highest.DNew); summary(preCOVIDtoDNew); anova(preCOVIDtoDNew)

#preCOVIDtoDTotal = lm(prcDTotal~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth+HDIadj, data=europe.highest.DTotal); summary(preCOVIDtoDTotal); anova(preCOVIDtoDTotal)  #

preCOVIDtoMort = lm(mortality.now~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth+HDIadj, data=europe.recent); summary(preCOVIDtoMort); anova(preCOVIDtoMort)  #

# try removing malta?   #### TODO: look at other outliers too? explain why each one should be removed/kept in. redo models with mortality rate?
withoutmaltaEtc = europe.recent[-c(28, 40),]  # removed malta, maybe also netherlands/belgium for density, switzerland for income, as outliers?
mortnoMaltaEtc = lm(mortality.now~ObesityPrc+ElderlyPrc+HCSpentPerCap+AQI+km.density+med.wealth, data=withoutmaltaEtc); summary(mortnoMaltaEtc); anova(mortnoMaltaEtc)

plot(europe.recent$ObesityPrc, europe.recent$mortality.now)
plot(europe.recent$ElderlyPrc, europe.recent$mortality.now)
plot(europe.recent$HCSpentPerCap, europe.recent$mortality.now)
plot(europe.recent$AQI, europe.recent$mortality.now)
plot(europe.recent$km.density, europe.recent$mortality.now)
plot(withoutmaltaEtc$km.density, withoutmaltaEtc$mortality.now)
plot(europe.recent$med.wealth, europe.recent$mortality.now)
plot(withoutmaltaEtc$med.wealth, withoutmaltaEtc$mortality.now)
plot(europe.recent$HDIadj, europe.recent$mortality.now)

woMaltafiltered = withoutmaltaEtc %>% filter(!is.na(AQI))  # AQI has the most missing values
eu.pca = select(woMaltafiltered, -c("Date_reported", "Country", "Country_code", "WHO_region")) %>% prcomp(center=TRUE, scale=TRUE)
plot(eu.pca, type="lines")
# pca.frame = data.frame(cbind(country=woMaltafiltered$Country, unclass(eu.pca$x)))
# woMfilt.long = pivot_longer(pca.frame, cols=!country, names_to="PC", values_to="Coefficient")
# woMfilt.long %>% filter(PC %in% c('PC1','PC2','PC3','PC4','PC5','PC6','PC7')) %>% ggplot(aes(x=country, y=Coefficient, colour = PC)) + geom_line()

# moving average model (dont use this yet! define a good question that we can make a good model for! few confounders, etc.)
# https://financetrain.com/estimating-moving-average-ma-model-in-r/
#US_MA = arima(x=UScovid$prcCNew)  #another var?
#US_MA; summary(US_MA)
#ts.plot(UScovid$prcCNew)
#resids = US_MA$residuals
#ts.plot(resids)
```

6.  Conduct model diagnostics and/or sensitivity analysis. 

```{r, echo=FALSE}

```

7. Conclude your analysis with a discussion of your findings and caveats of your approach. 

```{r, echo=FALSE}

```

```{r, ref.label=knitr::all_labels(),echo=TRUE,eval=FALSE}

```
